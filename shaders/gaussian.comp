#version 450

layout (local_size_x = 16, local_size_y = 16) in;

layout (binding = 0) buffer InputBuffer1 {
    vec4 data[];
} inputBuffer1;

layout (binding = 1) buffer InputBuffer2 {
    vec4 data[];
} inputBuffer2;

layout (binding = 2) buffer OutputBuffer {
    vec4 data[];
} outputBuffer;

void main() {
    const int kernelSize = 25; // Smaller kernel size
    const float sigma = 0.1; // Smaller sigma
    const float pi = 3.14159265;
    const float blurSize = 10.0;
    const int numBlurPixelsPerSide = (kernelSize - 1) / 2;

    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);
    int index = coords.y * 1024 + coords.x; // Assuming image width is 1024, adjust as needed

    // Calculate the Gaussian kernel
    float kernel[kernelSize];
    float sum = 0.0;
    for (int i = 0; i < kernelSize; i++) {
        float x = float(i - numBlurPixelsPerSide);
        kernel[i] = exp(-0.5 * (x * x) / (sigma * sigma)) / (sigma * sqrt(2.0 * pi));
        sum += kernel[i];
    }

    // Normalize the kernel
    for (int i = 0; i < kernelSize; i++) {
        kernel[i] /= sum;
    }

    // Apply the Gaussian blur horizontally
    vec3 avgValue = vec3(0.0);
    for (int i = -numBlurPixelsPerSide; i <= numBlurPixelsPerSide; i++) {
        int sampleIndex = index + i;
        if (sampleIndex >= 0 && sampleIndex < 1024 * 1024) { // Adjust for bounds
            avgValue += inputBuffer1.data[sampleIndex].rgb * kernel[i + numBlurPixelsPerSide];
        }
    }

    // Apply the Gaussian blur vertically
    vec3 blurredValue = vec3(0.0);
    for (int i = -numBlurPixelsPerSide; i <= numBlurPixelsPerSide; i++) {
        int sampleIndex = index + i * 1024; // Move vertically
        if (sampleIndex >= 0 && sampleIndex < 1024 * 1024) { // Adjust for bounds
            blurredValue += avgValue * kernel[i + numBlurPixelsPerSide];
        }
    }

    // Write the blurred value to the output buffer
    outputBuffer.data[index] = vec4(blurredValue, 1.0);
}
